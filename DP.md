 [动态规划题单](https://leetcode.cn/discuss/post/3581838/fen-xiang-gun-ti-dan-dong-tai-gui-hua-ru-007o/)

# 动态规划

> 关键思想：重叠子问题，最优子结构，状态转移方程

## 表现形式

1. 带备忘录（memo）的递归解法，即「自顶向下」
2. dp table的迭代解法，即「自底向上」

## 和回溯的区别

回溯专注于枚举，而动态规划主要是求最优解以及一些重叠子问题

有时候，有些计数问题有很多的重叠子问题，可以用回溯，但是如果直接回溯的话有可能会超时，所以这种情况一般选择可以解决重叠子问题的dp算法

## ==题型==

### 爬楼梯

> 最小组合问题，这里一定要注意记忆化，避免重复搜索

### 打家劫舍

> 如果取某一个元素，则无法同时取左右相邻元素

1. 若是环形问题（即第一个和最后一个也算相邻），则可以分成两种情况：不取第一个+不取最后一个，然后取两者最值

### 最大子数组和（53题）

有两种做法：

1. 定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是 f[i]=a[i]，和 i 左边拼起来就是 f[i]=f[i−1]+a[i]，取最大值就得到了状态转移方程 f[i]=max(f[i−1],0)+a[i]，答案为 max(f)   **Kadane 算法**

2. **前缀和**的形式，如第121题，可以转化成：求当前天数以前股票最低价

3. 若是环形问题，即数组可以跨越最后一个元素回到第一个元素，如第918问题，同样可以考虑两种情况：跨越末尾数组+不跨越末尾数组

   1. 不跨越整个数组：最基础的最大子数组和问题

   2. 跨越整个数组：数组和-最小子数组和

      > 解释：跨越末尾的子数组可以分成两段：左边的一段+右边的一段，不考虑开头和末尾的断开的话，就等价于整个数组总和-中间不选的部分（最小的连续子数组）

   3. 通过以上分析可以得知，似乎不跨越末尾数组的和也可以通过*整个数组总和-中间不选的部分*得到，那么为什么不能只考虑这一种情况呢
      A：当所有元素都是负数时，此时最小子数组就是这个数组本身，最后算出来的结果是0，但是题目要求必须得到至少一个元素，所以至少都得单独考虑这一种情况。
      同时，仔细分析可知，为什么不跨越末尾数组的和!=整个数组总和-中间不选的部分，如果该不跨越末尾数组是处在整个数组中间，也就是说此时该数组和=整个数组总和-前后两个子数组和

### 网格图dp

> 其实就是二维的dp数组，更新和一维的一致

1. 逆向dp（如题174）

   > Q1：为什么这里要用逆向dp
   > A：这里我们并不是想最大化路径和，而是要保证「任何时刻血量不能 ≤ 0」。所以我们需要知道 **当前位置至少要有多少血量** 才能撑到终点；如果我们仍然使用正向dp，我们可以知道自己现在的血量是多少，但并不知道未来路径会掉多少血，所以无法确定此刻的最小需求，即**正向dp无法保证未来存活**，所以我们需要用逆向dp，以保证「从这里出发到终点，一定能活下来」

   > Q2：如何推导转移方程
   > A：我们现在已知且确定`dp[i][j]`=从 `(i,j)` 出发到终点需要的最少初始 HP，在某个格子(i,j)，未来需要的hp是`min(dp[i+1][j], dp[i][j+1])`；同时，当前格子`dungeon[i][j]`的值会影响所需hp，所以`need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]`；再考虑到，hp>0，所以需要设置下限1`dp[i][j] = max(1, need)`

### 背包问题

1. 注意这里i的范围是0<=i<=N，j的范围是0<=j<=W

2. 0-1背包：每个物品只能用一次

   1. 二维dp：`dp[i][j]` 表示前 i 个物品、容量 j 的最优值，`dp[i][j]=max(dp[i−1][j],dp[i−1][j−wi]+vi)`

   2. 一维优化：由上述状态转移方程可知，`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，`dp[j]` 表示**背包容量为 j 时的最大价值**（或者是否可达、最小花费等），关键：**从大到小更新**
      ==注意这里倒序第二维的判断条件是j>=w[i]==

      ```cpp
      for (int i = 0; i < n; i++) {
          for (int j = W; j >= w[i]; j--) { // 倒序
              dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
          }
      }
      ```

   3. 部分题目需要一些思路的转化才能转换成0-1背包问题，详情见problem-494

   4. 关于正序倒序的问题

      > 解释：对于一维问题来说（即代价只有一个的时候），如果我们使用二维数组来进行dp的构造，则遍历顺序是正序，而如果此时的dp数组是一维数组，那么遍历顺序是倒序遍历；但是，当问题变成二维的时候（即代价有两个，详见problem-474）我们此时至少都要使用二维数组，这时遍历顺序是倒序，所以如何判断应该使用正序还是倒序呢？

      A：遍历顺序的本质是`更新时是否会用到已经更新过的状态`。

      - 对于一维约束的0-1背包，如果此时的dp数组是二维数组，则**第一维是物品维度**，所以可以天然避免重复使用，可以进行正序更新
      - 对于一维约束的0-1背包，如果此时的dp数组是一维数组，则此时**没有物品维度**，如果正序更新可能导致物品重复使用，比如，某物品重量为5(w[0]=5)，则
        dp[0]=0，
        dp[5]=max(dp[5],dp[5-5]+v[0])=dp[0]+v[0]
        dp[10]=max(dp[10],dp[10-5]+v[0])=dp[5]+v[0]=dp[0]+v[0]+v[0]
        此时第一个物品被放入两次
        即：
        正序更新时会用到刚更新过的 `dp[j-5]` → 相当于“再拿一次这个物品” → 完全背包效果
        倒序更新时用的还是旧的 `dp[j-5]` → 确保每个物品只用一次 → 01 背包效果
      - 对于二维约束的0-1背包，此时dp数组最少也是两维，**没有物品维度**，所以无法避免重复使用，只能倒序更新（原理如上一条所述）

      **总结：看该dp数组的设置是否包含物品维度，若包含，则可以正序进行，若不包含，则逆序遍历**

3. 完全背包

   1. 二维dp：`dp[i][j]=max(dp[i−1][j],dp[i][j−wi]+vi)`

   2. 一维优化：关键：正序，因为正序保证 `dp[j - w[i]]` 是当前物品的状态或者之前物品状态，**可以重复选当前物品**

      ```cpp
      for (int i = 0; i < n; i++) {
          for (int j = w[i]; j <= W; j++) { // 正序
              dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
          }
      }
      ```

### 经典线性dp

1. 最长公共子序列（LCS）

   1. 设 `dp[i][j]` = `s1[0..i-1]` 和 `s2[0..j-1]` 的 LCS 长度 所以此时定义vector的时候记得**容量大小要+1**

   2. 状态转移方程：

      1. 相等的话就+1
      2. 不相等的话 要么跳过s[i-1]，要么跳过t[j-1]

      $$
      dp[i][j] =
      \begin{cases} 
      dp[i-1][j-1] + 1 & \text{if } text1[i-1] = text2[j-1] \\[2mm]
      \max(dp[i-1][j], dp[i][j-1]) & \text{otherwise}
      \end{cases}
      $$

   3. 注意这里的子序列是否可以不连续

      1. subarray就是要连续的，所以当此时遍历到的两者不相等时，dp值赋值为0，结果最大值在每次两者相等时更新
      2. subsequence就是可以不连续的，就是像上面的状态转移方程即可

2. 最长递增子序列（LIS）-problem300

   1. 动态规划O(n^2^)

      1. `dp[i]` = 以 `nums[i]` 结尾的最长递增子序列长度
      2. 初始化：每个位置至少能构成长度为 1 的序列：`dp[i] = 1`
      3. **对每个 `j < i`，如果 `nums[j] < nums[i]`，则`dp[i] = max(dp[i], dp[j] + 1)`**

   2. 贪心+二分O(nlogn)

      1. 用一个数组 `tails[k]` 表示长度为 `k+1` 的递增子序列的 **最小结尾元素**
         最终 `tails` 并不是实际 LIS，**长度才是关键**，tails是**状态压缩**的结果

         Q：此时可能会有疑问，要是当前选中的比当前元素更大的元素不在tails数组的尾部，那么tail数组中的顺序和num数组中的顺序不一致，岂不是不能当成实际的LIS
         A：tails[i]表示的是长度为i+1的递增子序列的最小末尾值，比如

         - nums=[1,4,7,3]，前三次都是直接在尾部添加，也就是此时tails=[1,4,7]，搜索到nums[3]时，此时应该替换的位置时tails[2]，替换完成后tails数组变成了[1,3,7]，这是什么意思呢
         - 也就是说，长度为1的递增子序列的最小末尾值是1，长度为2的递增子序列的最小末尾值是3，长度为3的递增子序列的最小末尾值是7，也就是前面说的，**长度才是重点**

      2. 遍历 `nums`，对每个数用 **二分查找** 更新 `tails`：

         - 如果当前数比 `tails` 中所有数都大，就扩展序列长度；
         - 否则，用它更新某个位置（保证结尾尽可能小）