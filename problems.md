### 4

count表示**处理了几个元素**，它模拟走过合并数组的前 `mid2 + 1` 个元素

nums1:1,3,5,7,9
nums2:2,4,6,8,10
mid1=4,mid2=5

| count | pre  | cur  | index1 | index2 | nums1[index1] | nums2[index2] |
| ----- | ---- | ---- | ------ | ------ | ------------- | ------------- |
| 0     | 0    | 0    | 0      | 0      | 1             | 2             |
| 1     | 0    | 1    | 1      | 0      | 3             | 2             |
| 2     | 1    | 2    | 1      | 1      | 3             | 4             |
| 3     | 2    | 3    | 2      | 1      | 5             | 4             |
| 4     | 3    | 4    | 2      | 2      | 5             | 6             |
| 5     | 4    | 5    | 3      | 2      | 7             | 6             |

nums1:1,3
nums2:2
mid1:1,mid2:1

| count | pre  | cur  | index1 | index2 | nums1[index1] | nums2[index2] |
| ----- | ---- | ---- | ------ | ------ | ------------- | ------------- |
| 0     | 0    | 0    | 0      | 0      | 1             | 2             |
| 1     | 0    | 1    | 1      | 0      | 3             | 2             |

### 10

动态规划：dp\[i][j]表示s[0:i-1]能否与p[0:j-1]相匹配

![376d11a8f15ad8bc7763182304b1e11](./pics/376d11a8f15ad8bc7763182304b1e11.jpg)

### 29

首先，关于INT_MAX和INT_MIN的值：

- INT_MIN = -2,147,483,648 （即 -2³¹）
- INT_MAX = 2,147,483,647 （即 2³¹ - 1）

所以需要注意的第一点是一个特殊情况：当dividend == INT_MIN && divisor == -1时理论上结果应该是INT_MIN / -1 = 2,147,483,648；但是这个值超过了 INT_MAX（最大能表示到 2,147,483,647），所以会发生整数溢出（undefined behavior）

需要注意的第二点是这里的左移

- 左移<<1=乘2
- 右移>>1=除以2

这里巧妙利用了这一个特性，若被除数大于除数则将除数和商均左移1位
可能出现的情况比如

```
如果 a = 46, b = 5
第一次 temp = 5, temp << 1 = 10 ✅
temp = 10, temp << 1 = 20 ✅
temp = 20, temp << 1 = 40 ✅
temp = 40, temp << 1 = 80 ❌（超过 a=43）
-----------------------------------------
a-=temp，即a=6,res=8
a满足>=b的条件，temp=b=5，此时重新从temp<<1即10开始，不满足a>=(temp<<1)的条件，直接进行a-=temp，即a=1，multiple = 9
所以最终的 res=9
```

### 32

如何想到的**dp[i] 表示以 s[i] 结尾的最长有效括号子串的长度**

1. 成对的括号总是以）结尾
2. ==把状态 `dp[i]` 定义为以当前位置结尾的某种“最优子结构”==
   1. 最长上升子序列（LIS）：dp[i] 表示以 a[i] 结尾的 LIS 长
   2. 最大子数组和：dp[i] 表示以 a[i] 结尾的最大子数组和

### 41

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            // 把 nums[i] 放到正确的位置上
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        // 找到第一个不匹配的位置
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }
};
```

置换排序：把每个正数 `x` 放到下标 `x-1` 的位置，例如 `1` 放到 `nums[0]`，`2` 放到 `nums[1]`

### 42

思路：对于位置 `i`，它最多能接的水是 **min(左边最高柱子, 右边最高柱子) - height[i]**

### 46

Q：关于使用**回溯**时为什么有时用的是循环而有时不用循环：
A：**本质问题：当前决策有几个可选项**

> 回溯本质上是在每一个决策点穷举所有可能的选择，看当前决策点可以干什么，在46题中，每次只面临两个决策`是否要选择当前元素`，所以单独写这两个选项即可，而需要for循环的情况则大多出现在排列中，这类问题对顺序没有要求，只需要从剩下任意没用过的元素中选择一个来填充当前位置即可（如第78题）

### 72

编辑距离——一个我个人认为有点重要并且可以加深理解的题

`dp[i][j]` 表示 **把 word1 的前 i 个字符转换成 word2 的前 j 个字符所需的最少操作数**

插入：dp\[i][j]=1+dp\[i][j-1] 在 `word1` 后面插入 `word2[j-1]`，所以操作数 = `dp[i][j-1] + 1`
删除：dp\[i][j]=1+dp\[i-1][j] 把 `word1[i-1]` 删除掉，操作数 = `dp[i-1][j] + 1`
置换：dp\[i][j]=1+dp\[i-1][j-1] 把 `word1[i-1]` 替换成 `word2[j-1]`，所以操作数 = `dp[i-1][j-1] + 1`

而正常大部分情况下的LCS方法，只适用于只考虑删除操作，或者删除+插入操作的近似

一个扩展就是problem-712，这个题只包含删除和插入两个部分，也就是LCS方法，但是**此时的代价是ASCII值**

### 76

==经典的滑动窗口的问题==

首先，滑动窗口的本质，其核心逻辑是：

1. 扩张窗口，直到窗口满足条件
2. 收缩窗口，直到窗口不满足条件
3. 在这期间记录最优解

所以，谁是主循环取决于我们是要先扩张还是要先收缩。

Q：为什么此时要用右指针做循环而不是左指针？

A：滑动窗口其实是维护一个「当前子串」的信息，比如“每个字符出现的次数”“现在满足的条件（如less）”，使得我们在移动指针时不需要重新统计整个窗口，而是「增量更新」。此时如果让右指针做主循环，窗口信息是一直延续的，即右指针向右移动时加入一个元素，不满足条件后左指针右移，减少一个元素；而当左指针做主循环时，当不满足条件时左指针右移——好吧其实也可以

==**小tips：滑动窗口还是尽量右指针做主循环吧，规范一点**==

### 187

```c++
for(int i=0;i<s.size()-10;i++){
            string temp=s.substr(i,10);
            hmap[temp]++;
            cout<<1;
        }
```

Q：在s.size()==1的情况下为什么还会进入循环输出1？
A：`s.size()` 的返回类型是 `size_t`，是 **`unsigned`**，`s.size() - 10` 结果也就成了一个非常大的无符号数（因为 `1 - 10` 变成了一个超大的值，像 `18446744073709551607`）这就叫 **unsigned underflow（无符号整数下溢）**

### 210

返回时，如果要返回空的vector数组，有两种写法：

```c++
//第一种：        
if(res.size()==numCourses)
    return res;
return {};

//第二种
return res.size()==numCourses?res:vector<int>{};
```

注意这里的第二种写法

### 212

1. 暴力搜索：改进79的word-search，会超时
   改进：加一些数据预处理，比如，如果word里面含有boards中不存在的字符，或者某种字符的数量比boards中该字符数量更多，则根本不用进入dfs回溯，因为肯定无法形成该word
2. 字典树+dfs+回溯：这一部分思路有点混乱且难理解
   1. 根据words创建字典树->**字典树中所有的路径就是我们需要的word**
   2. 依旧遍历所有格子，以每一个格子为起始点，并对上下左右四个方向进行dfs
   3. 虽然以格子中的每一个点为起始点，但是实际遍历的是字典树，判断每一个格子节点是否符合字典树中每一个当前节点+下一个节点
   4. 如果能遍历到字典树尾部，则说明该字符串可以在格子中进行dfs得到

### 219

这里的进阶版有两个点：

1. 创建一个空的哈希表，在每次查找为空的时候再加入哈希表，可以避免访问同一个元素

2. 哈希表的key是数组值，value是数组下标，因为我们要通过数组值进行数组下标的对应

3. 代码

   ```cpp
   class Solution {
   public:
       bool containsNearbyDuplicate(vector<int>& nums, int k) {
           unordered_map<int,int> hmap;
   
           for(int i=0;i<nums.size();i++){
               int ptr=nums[i];
               if(hmap.find(ptr)!=hmap.end()){
                   //找到了
                   int dis=i-hmap[ptr];
                   if(dis<=k){
                       return true;
                   }
               }
               hmap[nums[i]]=i;
           }
           return false;
       }
   };
   ```

### 337

这个问题本质上是一个**树形dp+dfs**问题

首先，这里树的约束是「父子关系」，而不是「同层 vs 不同层」，如果按我本来的理解，是max{奇数层的总和，偶数层的总和}，但是还会出现一种情况比如

```markdown
    4
   /
  1
 /
2
 \
  3
```

此时最大值应该是4+3而不是4+2

Q1：那么该如何想到dp+dfs的组合呢？

> 首先，题目条件是不能同时偷父子节点，所以**「在每个节点上，会考虑两个状态：偷/不偷」**
> 其次，在前面失败一次后，很自然可以想到一种情况，也就是我偷的不是父亲和孙子节点，而是父亲和曾孙节点，也就是前文所示，那么如何知道该偷孙子还是曾孙呢，肯定要看孙子节点和曾孙节点或者更小的节点，也就是要**「自底向上」**，也就是dfs的思想：**「从根一路递归到叶子再返回，完成一个自底向上的dp转移」**

Q2：第二个问题是，这里对于每个节点有两个状态「偷/不偷」，正常dp是一个状态数组，这里怎么标识两个状态呢
A：pair<int,int>标识两个状态，或者其实二维数组也可。
		可以用返回值或者全局数组表示

Q3：确定顺序？
A：一般来说，像线性dp

- 一维数组可能是从左到右遍历
- 区间dp可能要按区间长度递增枚举
- 背包dp要注意循环顺序

​		像这种树形dp，可能就是自底向上的顺序

### 	401

题目解释：

- **4 个灯表示小时**（0–11），位置编号 `0~3`
- **6 个灯表示分钟**（0–59），位置编号 `4~9`

参数含义

- index：当前考虑的灯的编号（0-9）
- count：当前已经亮的灯的数量
- hour：小时值（位运算）
- minute：分钟值（位运算）

逻辑

```c++
for (int i = index; i < 10; i++) {
    if (i < 4)
        backtrack(i + 1, count + 1, hour | (1 << i), minute);
    else
        backtrack(i + 1, count + 1, hour, minute | (1 << (i - 4)));
}
```

首先，你是不是想着，他必须把“时”先全部点亮之后才能点亮“分”，但是！！你忘记了一件事情，**这是个循环！**这里的“i+1”可以**保证下一轮循环时，可选择的灯序号在当前选择的灯序号后面，不会重复选择之前的灯**，比如上一轮已经选择了0号灯，下一轮就只会在1-9号灯里面选，即i会遍历1-9，count表示在下一轮的时候已经点亮的几个灯

- i = 1 → 选小时灯第 1 位
- i = 2 → 选小时灯第 2 位
- i = 3 → 选小时灯第 3 位
- i = 4 → 选分钟灯第 0 位
- i = 5 → 选分钟灯第 1 位
- ......

### 447

思路：枚举中间，对于每一次枚举，用哈希表记录该数与其他数的距离差，最后使用有序排列的公式计算在该枚举情况下，排列的个数

### 494

Q：为什么不能变成：在数组 `nums` 里，能有多少种方法挑选出一个子集，使得子集和恰好等于 `target`
A：target可能为负数，无法变成0-1背包问题

Q：如何把这个问题转换成0-1背包问题？
A：如果 sum(nums) = S，target = T

- +a1+a2+⋯−ak+⋯=target
- 假设：
  - **P** = 所有取正号的元素之和
  - **N** = 所有取负号的元素之和
- 那么有：
  - P−N=target
  - P+N=S
- 联立上述方程，得2P=target+S
  所以得到P=(target+S)/2
- 所以问题转换成了：在数组 `nums` 里，能有多少种方法挑选出一个子集，使得子集和恰好等于 `(target + S) / 2`

### ==456==

### 673

> 遇到这个问题，首先可以明确两点：
>
> 1. 首先，该问题是个最长递增子序列的问题
> 2. 由于这个题目的设置存在许多重叠子问题，所以使用动态规划来进行解答
>
> 再继续往后思考，可以很顺企自然地想到，dp[i]表示以nums[i]结尾的最长递增子序列的个数，那么接下来会遇到一个问题，**如何能知道最长递增子序列的长度，或者说该最长递增子序列的末尾最大值？**

这里，gpt给我提供了一种思路，即**双数组动态规划**

首先，定义状态：

- `length[i]`：以 `nums[i]` 结尾的 **最长递增子序列的长度**
- `count[i]`：以 `nums[i]` 结尾的 **最长递增子序列的个数**

状态转移：遍历 `i`，在前面找所有 `j < i` 且 `nums[j] < nums[i]` 的元素：
$$
\text{if } nums[j] < nums[i]:
\quad
\begin{cases}
length[i] = length[j] + 1, \quad count[i] = count[j] & \text{if } length[j] + 1 > length[i] \\[2mm]
length[i] = length[i], \quad count[i] = count[i] + count[j] & \text{if } length[j] + 1 = length[i] \\[2mm]
length[i] = length[i], \quad count[i] = count[i] & \text{otherwise}
\end{cases}
$$
length的更新就是正常最长递增子序列的更新，即length[i]=max{length[i],length[j]+1}，而count的更新分成两个部分，一个部分是当length[j]+1>length[i]的时候，说明此时最长的长度需要被更新，count[i]=count[j]，此时最长的长度仅来源于count[j]，所以两者相等；另一方面，当length[j]+1==length[i]的时候，说明此时可以达到当前最长递增子序列长度的又多了一种路径（即经过j的），于是count[i]+=count[j]

最后：

- 找出全局的最长子序列长度 `maxLen = max(len[i])`。
- 把所有满足 `len[i] == maxLen` 的 `cnt[i]` 加起来，就是答案

### 827

==**如何进行上下左右四个方向的遍历**==

```c++
vector<pair<int,int>> dirs={{1,0},{-1,0},{0,1},{0,-1}};

for(int i=0;i<row;i++){
    for(int j=0;j<col;j++){
        for(auto& d:dirs){
            int r=i+d.first;
            int c=j+d.second;
            ......
        }
        ......
    }
}
```
